/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.michaelkoepf.spegauge.generators.nexmark;

import net.michaelkoepf.spegauge.api.common.model.nexmark.Event;
import net.michaelkoepf.spegauge.api.driver.EventGenerator;
import net.michaelkoepf.spegauge.api.driver.RateLimitInformation;
import net.michaelkoepf.spegauge.generators.nexmark.generator.AuctionGenerator;
import net.michaelkoepf.spegauge.generators.nexmark.generator.BidGenerator;
import net.michaelkoepf.spegauge.generators.nexmark.generator.PersonGenerator;
import net.michaelkoepf.spegauge.generators.nexmark.util.GeneratorConfig;
import org.apache.commons.rng.UniformRandomProvider;
import org.apache.commons.rng.simple.RandomSource;

/**
 * A generator for synthetic events. We try to make the data vaguely reasonable. We also ensure most
 * primary key/foreign key relations are correct. Eg: a {@link Event} event will usually have valid
 * auction and bidder ids which can be joined to already-generated Auction and Person events.
 *
 * <p>To help with testing, we generate timestamps relative to a given {@code baseTime}. Each new
 * event is given a timestamp advanced from the previous timestamp by {@code interEventDelayUs} (in
 * microseconds). The event stream is thus fully deterministic and does not depend on wallclock
 * time.
 */
public class NEXMarkEventGenerator implements EventGenerator {

  private static final net.michaelkoepf.spegauge.api.driver.Config CONFIG = new net.michaelkoepf.spegauge.generators.Config();

  private final UniformRandomProvider random;

  /**
   * Configuration to generate events against. Note that it may be replaced by a call to {@link
   * #splitAtEventId}.
   */
  private GeneratorConfig config;

  /** Number of events generated by this generator. */
  private long eventsCountSoFar;

  /** Wallclock time at which we emitted the first event (ms since epoch). Initially -1. */
  private long wallclockBaseTime;

  private final boolean isRateLimited;

  private final RateLimitInformation rateLimitInformation;

  public NEXMarkEventGenerator(GeneratorConfig config, long eventsCountSoFar, long wallclockBaseTime, boolean isRateLimited, int numberOfGenerators) {
    if (config == null) {
      throw new IllegalArgumentException("config must not be null");
    }
    this.config = config;
    this.eventsCountSoFar = eventsCountSoFar;
    this.wallclockBaseTime = wallclockBaseTime;
    this.random = CONFIG.getDefaultRandomSource().create(config.seed);
    this.isRateLimited = isRateLimited;
    this.rateLimitInformation = new RateLimitInformation(config.configuration.firstEventRate, numberOfGenerators);
  }

  /** Create a fresh generator according to {@code config}. */
//  public NEXMarkEventGenerator(GeneratorConfig config) {
//    this(config, 0, -1);
//  }

  /** Return a deep copy of this generator. */
  public NEXMarkEventGenerator copy() {
    // TODO
    throw new UnsupportedOperationException();
  }


  /**
   * Return the current config for this generator. Note that configs may be replaced by {@link
   * #splitAtEventId}.
   */
  public GeneratorConfig getCurrentConfig() {
    return config;
  }

  /**
   * Mutate this generator so that it will only generate events up to but not including {@code
   * eventId}. Return a config to represent the events this generator will no longer yield. The
   * generators will run in on a serial timeline.
   */
  public GeneratorConfig splitAtEventId(long eventId) {
    long newMaxEvents = eventId - (config.firstEventId + config.firstEventNumber);
    GeneratorConfig remainConfig =
        config.copyWith(
            config.firstEventId,
            config.maxEvents - newMaxEvents,
            config.firstEventNumber + newMaxEvents);
    config = config.copyWith(config.firstEventId, newMaxEvents, config.firstEventNumber);
    return remainConfig;
  }

  /**
   * Return the next 'event id'. Though events don't have ids we can simulate them to help with
   * bookkeeping.
   */
  public long getNextEventId() {
    return config.firstEventId + config.nextAdjustedEventNumber(eventsCountSoFar);
  }

  @Override
  public boolean hasNext() {
    return eventsCountSoFar < config.maxEvents;
  }

  @Override
  public net.michaelkoepf.spegauge.api.driver.Event next() {
    if (wallclockBaseTime < 0) {
      wallclockBaseTime = System.currentTimeMillis();
    }
    // When, in event time, we should generate the event. Monotonic.
    long eventTimestamp = config.timestampForEvent(config.nextEventNumber(eventsCountSoFar));
    // When, in event time, the event should say it was generated. Depending on outOfOrderGroupSize
    // may have local jitter.
    long adjustedEventTimestamp =
        config.timestampForEvent(config.nextAdjustedEventNumber(eventsCountSoFar));
    // The minimum of this and all future adjusted event timestamps. Accounts for jitter in
    // the event timestamp.
    long watermark = config.timestampForEvent(config.nextEventNumberForWatermark(eventsCountSoFar));
    // When, in wallclock time, we should emit the event.
    long wallclockTimestamp = wallclockBaseTime + (eventTimestamp - getCurrentConfig().baseTime);

    long newEventId = getNextEventId();
    long rem = newEventId % config.totalProportion;

    Event event;
    if (rem < config.personProportion) {
      event =
          new Event(PersonGenerator.nextPerson(newEventId, random, adjustedEventTimestamp, config));
    } else if (rem < config.personProportion + config.auctionProportion) {
      event =
          new Event(
              AuctionGenerator.nextAuction(
                  eventsCountSoFar, newEventId, random, adjustedEventTimestamp, config));
    } else {
      event = new Event(BidGenerator.nextBid(newEventId, random, adjustedEventTimestamp, config));
    }

    eventsCountSoFar++;
    return new NEXMarkEvent(wallclockTimestamp, adjustedEventTimestamp, event, watermark);
  }

  @Override
  public void remove() {
    throw new UnsupportedOperationException();
  }

  /** Return an estimate of fraction of output consumed. */
  public double getFractionConsumed() {
    return (double) eventsCountSoFar / config.maxEvents;
  }

  /** Gets Number of events generated by this generator. */
  public long getEventsCountSoFar() {
    return eventsCountSoFar;
  }

  @Override
  public String toString() {
    return String.format(
        "Generator{config:%s; eventsCountSoFar:%d; wallclockBaseTime:%d}",
        config, eventsCountSoFar, wallclockBaseTime);
  }

  @Override
  public boolean isRateLimited() {
    return isRateLimited;
  }

  @Override
  public RateLimitInformation getRateLimitInformation() {
    return rateLimitInformation;
  }

}
